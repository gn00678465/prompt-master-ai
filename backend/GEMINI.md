
# Gemini Codebase Analysis: PromptMaster AI Backend

This document provides a comprehensive analysis of the PromptMaster AI backend codebase, generated by Gemini. It is intended to help developers understand the project's architecture, key components, and core functionalities.

## 1. Project Overview

The backend for PromptMaster AI is a robust API service built with Python and FastAPI. Its primary purpose is to provide a secure and efficient platform for users to optimize their AI prompts using Google's Gemini models. The system supports user authentication, prompt template management, optimization history tracking, and direct interaction with the Gemini API.

## 2. Core Technologies

- **Web Framework**: **FastAPI** is used for building the asynchronous API, offering high performance, automatic interactive documentation (Swagger UI, ReDoc), and a modern development experience.
- **Database ORM**: **SQLModel** serves as the object-relational mapper (ORM), combining Pydantic models with SQLAlchemy for intuitive data modeling and database interaction.
- **Database Engine**: **SQLite** is the default database for development, configured via `alembic.ini` and the application's environment settings.
- **Database Migrations**: **Alembic** is used to manage database schema migrations, ensuring that database changes are version-controlled and reproducible.
- **Authentication**: **JSON Web Tokens (JWT)** are used for securing API endpoints. Passwords are hashed using **Argon2**.
- **AI Integration**: The `google-genai` library is used to communicate with the **Google Gemini API** for prompt optimization.
- **Caching & In-memory Storage**: **Redis** is integrated for managing the JWT token blacklist, enabling a secure logout mechanism.
- **Dependency Management**: Dependencies are listed in `pyproject.toml` and a `requirements.txt` file is also provided. `uv` is the recommended tool for syncing dependencies.
- **Code Style & Linting**: **Ruff** is configured in `pyproject.toml` for code formatting and linting to maintain a consistent and clean codebase.

## 3. Project Structure

The backend code is logically organized into several directories within the `app/` folder:

```
app/
├── api/           # API endpoint routers (the "Controllers")
├── models/        # SQLModel database table definitions
├── schemas/       # Pydantic models for request/response data validation
├── services/      # Business logic and interactions with external services (e.g., Gemini API)
├── utils/         # Utility functions for security, token management, and Redis
├── config.py      # Environment variable management
├── dependencies.py# Dependency injection functions (e.g., database session)
└── main.py        # FastAPI application entry point
```

## 4. Key Features & Logic

### 4.1. Application Entrypoint (`main.py`)

- Initializes the FastAPI application.
- Sets up CORS middleware to allow requests from the frontend.
- Includes all the API routers from the `app.api` module.
- Uses a `lifespan` context manager to create database tables and check the Redis connection on startup.

### 4.2. Authentication (`api/auth.py`, `utils/security.py`, `utils/token.py`)

- **Registration (`POST /api/auth/register`)**: Hashes the user's password with Argon2 and stores the new user in the database.
- **Login (`POST /api/auth/login`)**: Verifies credentials and, if successful, generates and returns a JWT access token.
- **Token Generation**: The `create_access_token` function in `utils/token.py` creates a JWT containing the user's identity.
- **Logout (`POST /api/auth/logout`)**: The current user's token is added to a Redis blacklist. The `is_token_blacklisted` utility checks against this list for subsequent requests.
- **Protected Endpoints**: Endpoints are protected using a `get_current_user` dependency, which decodes the JWT and retrieves the active user from the database.

### 4.3. Prompt Optimization (`api/optimize.py`, `services/prompt_optimizer.py`)

- The main business logic resides in the `PromptOptimizer` service.
- It receives an original prompt, a template, and a model choice.
- It constructs a formatted request using the selected template and sends it to the `GeminiClient` service.
- The `GeminiClient` (`services/gemini_client.py`) handles the actual communication with the Google Gemini API.
- After receiving the optimized prompt from Gemini, the system logs the entire transaction (original prompt, optimized prompt, template used, etc.) to the `PromptHistory` table.

### 4.4. Database Models (`models/`)

- `user.py`: Defines the `User` table with fields for username and hashed password.
- `template.py`: Defines the `Template` table for storing prompt templates.
- `prompt_history.py`: Defines the `PromptHistory` table to log every optimization event, linked to a user.
- `token_blacklist.py`: Defines the `TokenBlacklist` table to store expired/logged-out JWTs.

### 4.5. Configuration (`config.py`)

- A `Settings` class inherits from Pydantic's `BaseSettings`.
- It loads sensitive keys, database URLs, and other configuration parameters from environment variables (defined in a `.env` file), providing a centralized and secure way to manage application settings.

## 5. Setup and Execution

1.  **Environment**: Create a `.env` file in the `backend/` directory based on `.env.example`.
2.  **Dependencies**: Install the required Python packages using `uv sync` or `pip install -r requirements.txt`.
3.  **Database Migration**: Run `alembic upgrade head` to apply the latest database schema.
4.  **Run Server**: Execute `python -m app` from the `backend/` directory to start the development server.

## 6. API Endpoints

The API is structured logically by resource:

- `/api/auth/*`: User registration, login, logout, and user info.
- `/api/prompts/optimize`: The core endpoint for optimizing a prompt.
- `/api/history`: Retrieves the optimization history for the authenticated user.
- `/api/templates`: CRUD operations for managing prompt templates.
- `/api/models`: Lists the available Gemini models for optimization.
